using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Text;
using System.Windows.Forms;
using System.Collections;
using System.Threading;
using System.IO;

using Cognex.VisionPro;
using Cognex.VisionPro.QuickBuild;
using Cognex.VisionPro.QuickBuild.Implementation.Internal;
using Cognex.VisionPro.ToolGroup;
using Cognex.VisionPro.Implementation;

namespace VisionControl
{
  public enum AccessLevel { Operator, Supervisor, Administrator }

  public partial class VisionControl : UserControl
  {
    #region Private data
    private const int MaximumPeriodMs = 500;
    private const int MinimumPeriodMs = 50;
    private System.Threading.Timer mMaximumGuiPeriodTimer;
    private System.Threading.Timer mMinimumGuiPeriodTimer;
    private bool mMinimumGuiUpdateNeeded = false;
    private bool mHaveUnpaintedResults = false;

    // Queue lengths, for the "all results" and "failing results" queues.
    // To disable the "failing results" queue, set its length to 1.  Queues must always be a least 1 element
    // in length, to hold the current result.
    private const int AllQueueLength = 16;
    private const int FailureQueueLength = 16;

    private PasswordFile mCurrentPasswordFile;
    private string mLoadedVppFilename;

    private OptionsFile mCurrentOptionsFile;

    private CogJobManager mJM = null;
    private bool mAttached = false;
    private int mSelectedJob = 0;
    private AccessLevel mCurrentAccessLevel;
    private CogJobResultHistoryCollection mHistoryCollection = new CogJobResultHistoryCollection();

    private enum RunState { Stopped, RunningContinuous, RunningOnce, RunningLive };
    private RunState mCurrentRunState = RunState.Stopped;
    private JobData[] mJobData = null;
    private bool mInitError = false;
    private bool mStarted = false;
    private bool mIsClosing = false;

    // resource support for localization
    private Hashtable mResultTextHash;
    #endregion

    #region Public interface
    /// <summary>
    /// Read-only property to retrieve the CogJobManager.
    /// </summary>
    public CogJobManager JobManager
    {
      get { return mJM; }
    }

    /// <summary>
    /// Read-only property to retrieve the application name.
    /// </summary>
    public string ApplicationName
    {
      get { return mApplicationName; }
    }

    /// <summary>
    /// Read-only property to retrieve the filename of the loaded .vpp file.
    /// </summary>
    public string LoadedVppFilename
    {
      get { return mLoadedVppFilename; }
    }

    /// <summary>
    /// Read-only property indicating if passwords are in use by the generated code or not.
    /// </summary>
    public bool UsingPasswords
    {
      get { return mUsePasswords; }
    }

    /// <summary>
    /// If passwords are in use, returns the current password file.
    /// </summary>
    public PasswordFile CurrentPasswordFile
    {
      get { return mCurrentPasswordFile; }
    }

    /// <summary>
    /// Read-only property indicating the time at which this code was generated by the wizard.
    /// </summary>
    public static DateTime GenerationDateTime
    {
      get { return mGenerationDateTime; }
    }

    /// <summary>
    /// Read-only property indicating the what version of the wizard was used to generate this code.
    /// </summary>
    public static string GeneratedByVersion
    {
      get { return mGeneratedByVersion; }
    }

    /// <summary>
    /// Event fired for every user result produced by a job in the QuickBuild application (.vpp
    /// file).  The event is fired by the job thread itself, so any subscribers must handle this
    /// event in a timely manner.
    /// </summary>
    public event VisionControlUserResultAvailableEventHandler VisionControlUserResultAvailable = null;

    /// <summary>
    /// Clears all results from the result history queues of all jobs.
    /// </summary>
    public void ClearHistoryQueues(object sender, EventArgs e)
    {
      if (this.InvokeRequired)
      {
        // Call this same function on the GUI thread.
        Invoke(new EventHandler(ClearHistoryQueues), new object[] { sender, e });
        return;
      }

      foreach (ICogJobResultHistory h in mHistoryCollection)
      {
        h.Clear();
      }
    }

    /// <summary>
    /// This method serves to close the VisionControl. 
    /// It unsubscribes from the events of the JobManager instance and calls Shutdwon on it.
    /// Therefore this method should be called only at closing the Vision Application.
    /// </summary>
    public void Close()
    {
        AttachToJobManager(false);
        mIsClosing = true;
        if (mJM != null)
        {
            mJM.Shutdown();
            mJM = null;
        }
    }
    #endregion

    #region Initialization
    /*
     * For the vpp filename, first check using the full path supplied when the application
     * was generated.  This is intended for use primarily on developer machines.  If this
     * filename does not exist, then look in the same directory as the executable for
     * the vpp file, using just the filename portion.  This is the expected deployment
     * configuration.
     * 
     * For other files (such as the about box text file and password text file), first
     * check in the same directory as the vpp file, using the full path supplied when the
     * application was generated.  Then look in the same directory as the executable.
     */

    private static string ResolveVppFilename()
    {
      string fname = mVppFilename;

      // check if the developer vpp file path exists
      if (!System.IO.File.Exists(fname))
      {
        // if not, then try the filename in the same directory as this executable
        string justFilename = System.IO.Path.GetFileName(fname);
        fname = Utility.GetThisExecutableDirectory() + justFilename;
      }

      return fname;
    }

    public VisionControl()
    {
      InitializeComponent();
    }

    private bool PerformRequiredInit()
    {
      // resolve the quickbuild filename
      string vppFileToLoad = ResolveVppFilename();
      if (!File.Exists(vppFileToLoad) && !File.Exists(mVppFilename))
      {
        // vpp file does not exist in either developer location or current dir
        label_controlErrorMessage.Text = ResourceUtility.FormatString("RtVppNotFound", vppFileToLoad, mVppFilename);
        return false;
      }

      // create, validate & setup the password file
      string passwordfname = Utility.ResolveAssociatedFilename(mVppFilename, "passwords.txt");
      mCurrentPasswordFile = new PasswordFile(passwordfname);
      if (mCurrentPasswordFile.PasswordFileFound && !mCurrentPasswordFile.PasswordFileValid)
      {
        string quoted = "\"" + mCurrentPasswordFile.PasswordFilename + "\"";
        label_controlErrorMessage.Text = ResourceUtility.FormatString("RtInvalidPasswordFile", quoted);
        return false;
      }
      mCurrentPasswordFile.SetDefaultPassword(AccessLevel.Administrator, mDefaultAdministratorPassword);
      mCurrentPasswordFile.SetDefaultPassword(AccessLevel.Supervisor, mDefaultSupervisorPassword);

      // load the QuickBuild project file
      try
      {
        mJM = (CogJobManager)CogSerializer.LoadObjectFromFile(vppFileToLoad);
      }
      catch (Exception ex)
      {
        label_controlErrorMessage.Text =  ResourceUtility.GetString("RtErrorLoadingVpp") + ex.Message;
        return false;
      }

      mLoadedVppFilename = vppFileToLoad;

      // check for an uninitialized acquisition configuration
      for (int i = 0; i < mJM.JobCount; ++i)
      {
        if (mJM.Job(i).AcqFifoState == CogJobAcqFifoStateConstants.Invalid)
        {
          label_controlErrorMessage.Text = ResourceUtility.FormatString("RtUninitializedAcq", mLoadedVppFilename);
          return false;
        }
      }

      return true;
    }

    private void StartApplication()
    {
      if (mStarted)
        return;

      mStarted = true;
      mInitError = !PerformRequiredInit();

      if (mInitError)
      {
        cogRecordsDisplay1.Hide();
        tabControl_JobTabs.Hide();
        splitter2.Hide();
        panel6.Hide();
        UpdateControlsEnabled();
        return;
      }

      // create options file, read
      mCurrentOptionsFile = new OptionsFile();
      mCurrentOptionsFile.Read();

      // set the job manager to always generate user result records, even if nothing
      // was added to the user queue within QuickBuild
      mJM.UserQueueResultCreation = CogUserQueueResultCreationConstants.Always;

      // Flush queues
      Utility.FlushAllQueues(mJM);

      // Set up stats
      for (int i = 0; i < mJM.JobCount; i++)
        mJM.Job(i).ThroughputAlgorithm = CogJobThroughputAlgorithmConstants.MovingAverage;
      ResetStatisticsForAllJobs();

      try
      {
        Wizard_FormLoad();
      }
      catch (System.ArgumentOutOfRangeException)
      {
        // do nothing - handles case where fewer jobs than expected are
        // present in job manager
      }

      try
      {
        // resolve the logo filename
        string logoFilename = Utility.ResolveAssociatedFilename(mVppFilename, "logo.bmp");
        pictureBox_Logo.Image = new System.Drawing.Bitmap(logoFilename);

        // size the logo area to the needed height, and center the bitmap in that area
        int width = pictureBox_Logo.Size.Width;
        pictureBox_Logo.SizeMode = PictureBoxSizeMode.AutoSize;
        int height = pictureBox_Logo.Size.Height;
        pictureBox_Logo.SizeMode = PictureBoxSizeMode.CenterImage;
        pictureBox_Logo.Size = new System.Drawing.Size(width, height + 4);
      }
      catch (System.ArgumentException)
      {
        // do nothing - handles case where logo bitmap is not supplied
      }

      AttachToJobManager(true);
      UpdateGUIForSelectedJobChange(-1);

      // select the first tab page to start
      if (tabControl_JobTabs.TabPages.Count > 0)
        tabControl_JobTabs.SelectedTab = tabControl_JobTabs.TabPages[0];

      SetResultBarCurrent();

      // size result history window to number of jobs (or 8 max)
      const int maxJobsToSizeTo = 8;
      int rowHeight = cogJobResultHistoryCollectionEdit1.SelectorControlHeight;
      int totalHeight = rowHeight * (mJM.JobCount > maxJobsToSizeTo ? maxJobsToSizeTo : mJM.JobCount) + 8;
      int newPanel1Height = totalHeight + panel1.Height - cogJobResultHistoryCollectionEdit1.Height;
      if (panel1.Height < newPanel1Height)
        panel1.Height = newPanel1Height;
      if (mJM.JobCount > maxJobsToSizeTo)
      {
        // scale height of each row to fit remaining jobs (up to 10)
        const int maxJobsToScaleTo = 10;
        int scaleToFit = mJM.JobCount > maxJobsToScaleTo ? maxJobsToScaleTo : mJM.JobCount;
        int controlSpace = cogJobResultHistoryCollectionEdit1.Height - 4;
        cogJobResultHistoryCollectionEdit1.SelectorControlHeight = controlSpace / scaleToFit;
      }

      // setup the gui update timers
      mMaximumGuiPeriodTimer = new System.Threading.Timer(new System.Threading.TimerCallback(mMaximumGuiPeriodTimer_Elapsed), null,
        MaximumPeriodMs, MaximumPeriodMs);
      mMinimumGuiUpdateNeeded = false;
      mHaveUnpaintedResults = false;
      mMinimumGuiPeriodTimer = new System.Threading.Timer(new System.Threading.TimerCallback(mMinimumGuiPeriodTimer_Elapsed), null,
        MinimumPeriodMs, MinimumPeriodMs);

      // call required IO function
      mJM.IOPostLoadSetup(true);

      // enable IO if selected by options file
      if (mCurrentOptionsFile.EnableIOAtStartup)
      {
        try
        {
          mJM.IOEnable = true;
        }
        catch (Cognex.VisionPro.Exceptions.CogException)
        { }
      }

      // start heartbeats, if QuickBuild app is configured for them
      mJM.RequestHeartbeat();
    }

    private void VisionControl_Load(object sender, EventArgs e)
    {
      // perform initialization to update the control gui - remainder of initialization
      // takes place in StartApplication
      if (mUsePasswords)
        mCurrentAccessLevel = AccessLevel.Operator;
      else
      {
        mCurrentAccessLevel = AccessLevel.Administrator;
        this.label_Login.Visible = false;
        this.comboBox_Login.Visible = false;
      }

      this.btnRun.Text = ResourceUtility.GetString("RtRunOnceButton");
      this.btnRunCont.Text = ResourceUtility.GetString("RtRunContinuouslyButton");
      this.button_About.Text = ResourceUtility.GetString("RtAboutButton");
      this.button_Configuration.Text = ResourceUtility.GetString("RtConfigurationButton");
      this.checkBox_LiveDisplay.Text = ResourceUtility.GetString("RtLiveImageButton");
      this.button_SaveSettings.Text = ResourceUtility.GetString("RtSaveSettingsButton");

      this.label_Login.Text = ResourceUtility.GetString("RtCurrentLogin");

      comboBox_Login.Items.Add(new AccessLevel_Localized(AccessLevel.Operator, ResourceUtility.GetString("RtOperator")));
      comboBox_Login.Items.Add(new AccessLevel_Localized(AccessLevel.Supervisor, ResourceUtility.GetString("RtSupervisor")));
      comboBox_Login.Items.Add(new AccessLevel_Localized(AccessLevel.Administrator, ResourceUtility.GetString("RtAdministrator")));
      comboBox_Login.SelectedIndex = 0;

      label_Online.Text = ResourceUtility.GetString("RtSystemOffline");

      tabPage_JobN_JobStatistics.Text = ResourceUtility.GetString("RtStatsPageTitle");
      groupBox_JobResults.Text = ResourceUtility.GetString("RtStatsJobResultsGroup");
      label_JobResults_TotalIterations.Text = ResourceUtility.GetString("RtStatsJobIterations");
      label_JobResults_Accept.Text = ResourceUtility.GetString("RtStatsJobAcceptCount");
      label_JobResults_Error.Text = ResourceUtility.GetString("RtStatsJobErrorCount");
      label_JobResults_Reject.Text = ResourceUtility.GetString("RtStatsJobRejectCount");
      label_JobResults_Warning.Text = ResourceUtility.GetString("RtStatsJobWarningCount");
      label_JobResults_Percent.Text = ResourceUtility.GetString("RtStatsPercent");
      groupBox_AcquisitionResults.Text = ResourceUtility.GetString("RtStatsAcquisitionResultsGroup");
      label_AcquisitionResults_TotalAcquisitions.Text = ResourceUtility.GetString("RtStatsAcquisitions");
      label_AcquisitionResults_Errors.Text = ResourceUtility.GetString("RtStatsAcqErrorCount");
      label_AcquisitionResults_Overruns.Text = ResourceUtility.GetString("RtStatsAcqOverrunCount");
      groupBox_JobThroughput.Text = ResourceUtility.GetString("RtStatsJobThroughputGroup");
      label_JobThroughput_TotalThroughput.Text = ResourceUtility.GetString("RtStatsJobThroughput");
      label_JobThroughput_Min.Text = ResourceUtility.GetString("RtStatsThroughputMin");
      label_JobThroughput_Max.Text = ResourceUtility.GetString("RtStatsThroughputMax");
      label_JobThroughput_persec.Text = ResourceUtility.GetString("RtStatsPerSecond");
      button_ResetStatistics.Text = ResourceUtility.GetString("RtStatsReset");
      button_ResetStatisticsForAllJobs.Text = ResourceUtility.GetString("RtStatsResetAll");

      this.mResultTextHash = new Hashtable();
      this.mResultTextHash.Add(CogToolResultConstants.Accept, ResourceUtility.GetString("RtAccept"));
      this.mResultTextHash.Add(CogToolResultConstants.Warning, ResourceUtility.GetString("RtWarning"));
      this.mResultTextHash.Add(CogToolResultConstants.Reject, ResourceUtility.GetString("RtReject"));
      this.mResultTextHash.Add(CogToolResultConstants.Error, ResourceUtility.GetString("RtError"));

      if (!DesignMode)
        StartApplication();
    }

    private void AttachToJobManager(bool attach)
    {
      // attach and detach our event handlers/etc
      if (attach)
      {
        if (mAttached)
          return;

        try
        {
          Wizard_AttachPropertyProviders();
        }
        catch (System.ArgumentOutOfRangeException)
        {
          // do nothing - handles case where fewer jobs than expected are
          // present in job manager
        }

        mAttached = true;

        // Create a collection of history items for each job.
        // Preserve the history of any jobs that we already have - create new items for any
        // new jobs.
        CogJobResultHistoryCollection jobs = new CogJobResultHistoryCollection();
        bool changed = false;
        for (int j = 0; j < mJM.JobCount; ++j)
        {
          int i = mHistoryCollection.IndexOf(mJM.Job(j).Name);
          if (i != -1)
          {
            if (i != jobs.Count) changed = true;
            jobs.Add(mHistoryCollection[i]);
          }
          else
          {
            jobs.Add(new CogJobResultHistoryGated(mJM.Job(j).Name, AllQueueLength, FailureQueueLength));
            changed = true;
          }
        }
        if (jobs.Count != mHistoryCollection.Count)
          changed = true;
        if (changed)
        {
          mHistoryCollection = jobs;
          cogJobResultHistoryCollectionEdit1.Subject = jobs;
          mSelectedJob = 0;
        }

        foreach (CogJobResultHistoryGated hist in mHistoryCollection)
        {
          hist.CurrentItemChanged += new EventHandler(cogJobResultHistory_CurrentItemChanged);
          hist.InternalQueue.CurrentQueueChanged += new EventHandler(cogJobResultHistory_RequestImmediateUpdate);
          hist.InternalQueue.CurrentItemChanged += new EventHandler(cogJobResultHistory_RequestImmediateUpdate);
        }
        mJM.Stopped += new CogJobManager.CogJobManagerStoppedEventHandler(mJM_Stopped);
        mJM.UserResultAvailable += new CogJobManager.CogUserResultAvailableEventHandler(mJM_UserResultAvailable);
        mJM.Changed += new CogChangedEventHandler(mJM_ChangedHandler);

        for (int i = 0; i < mJM.JobCount; ++i)
        {
          mJM.Job(i).Running += new CogJob.CogJobRunningEventHandler(Job_Running);
          mJM.Job(i).ImageQueueOverflowed += new CogJob.CogImageQueueOverflowedEventHandler(Job_ImageQueueOverflowed);
        }

        // pull off and handle any items currently in the UserQueue
        HandleUserResults();

        // update the state of controls to reflect any changes made in config mode
        UpdateControlsEnabled();
        UpdateOnlineStatus();
      }
      else
      {
        if (!mAttached)
          return;

        Wizard_DetachPropertyProviders();
        mAttached = false;

        foreach (CogJobResultHistoryGated hist in mHistoryCollection)
        {
          hist.CurrentItemChanged -= new EventHandler(cogJobResultHistory_CurrentItemChanged);
          hist.InternalQueue.CurrentQueueChanged -= new EventHandler(cogJobResultHistory_RequestImmediateUpdate);
          hist.InternalQueue.CurrentItemChanged -= new EventHandler(cogJobResultHistory_RequestImmediateUpdate);
        }

        mJM.Stopped -= new CogJobManager.CogJobManagerStoppedEventHandler(mJM_Stopped);
        mJM.UserResultAvailable -= new CogJobManager.CogUserResultAvailableEventHandler(mJM_UserResultAvailable);
        mJM.Changed -= new CogChangedEventHandler(mJM_ChangedHandler);

        for (int i = 0; i < mJM.JobCount; ++i)
        {
          mJM.Job(i).Running -= new CogJob.CogJobRunningEventHandler(Job_Running);
          mJM.Job(i).ImageQueueOverflowed -= new CogJob.CogImageQueueOverflowedEventHandler(Job_ImageQueueOverflowed);
        }
      }
    }
    #endregion

    #region Runtime implementation
    private void btnRun_Click(object sender, System.EventArgs e)
    {
      if (mJM.JobsRunningState != CogJobsRunningStateConstants.None)
        return;

      // update control state here to prevent an error from a quick button doubleclick
      mCurrentRunState = RunState.RunningOnce;
      UpdateControlsEnabled();

      try
      {
        mJM.Run();

        // note that mJM_Stopped will be called when run is complete
      }
      catch (Cognex.VisionPro.Exceptions.CogNotStoppedException)
      {
        // do nothing in this case - we're already running
      }
      catch (Cognex.VisionPro.Exceptions.CogException ex)
      {
        mCurrentRunState = RunState.Stopped;
        UpdateControlsEnabled();
        MessageBox.Show(ResourceUtility.GetString("RtUnexpectedErrorQB") + ex.Message,
          mApplicationName);
      }
    }

    private void btnRunCont_Click(object sender, System.EventArgs e)
    {
      if (mCurrentRunState == RunState.RunningContinuous)
      {
        // Stop continuous
        mJM.Stop();

        // note that mJM_Stopped will be called when job manager has completed this stop
        // request
      }
      else
      {
        // update control state here to prevent an error from a quick button doubleclick
        mCurrentRunState = RunState.RunningContinuous;
        UpdateControlsEnabled();

        try
        {
          mJM.RunContinuous();
        }
        catch (Cognex.VisionPro.Exceptions.CogNotStoppedException)
        {
          // do nothing in this case - we're already running
        }
        catch (Cognex.VisionPro.Exceptions.CogException ex)
        {
          mCurrentRunState = RunState.Stopped;
          UpdateControlsEnabled();
          MessageBox.Show(ResourceUtility.GetString("RtUnexpectedErrorQB") + ex.Message,
            mApplicationName);
        }
      }
    }

    private void UpdateControlsEnabled()
    {
      // Enable or disable controls based on our current run state
      bool running = mCurrentRunState != RunState.Stopped;
      bool runningLive = mCurrentRunState == RunState.RunningLive;
      bool runningContinuous = mCurrentRunState == RunState.RunningContinuous;
      bool currentJobCanLive = mJM != null && mJM.JobCount > mSelectedJob && mJM.Job(mSelectedJob).AcqFifo != null;

      bool canConfig = !running && mCurrentAccessLevel == AccessLevel.Administrator;
      bool canSaveSettings = !running && mCurrentAccessLevel >= AccessLevel.Supervisor;

      btnRun.Enabled = !mInitError && !running;
      button_Configuration.Enabled = !mInitError && canConfig;
      button_SaveSettings.Enabled = !mInitError && canSaveSettings;
      button_About.Enabled = !running;

      if (mInitError)
      {
        label_Login.Enabled = false;
        comboBox_Login.Enabled = false;
        label_Online.Enabled = false;
      }

      // live display button is enabled if the current job can run live and either
      //   we're not running and the live display button is "up" or
      //   we are running and the live display button is "down"
      checkBox_LiveDisplay.Enabled = !mInitError && currentJobCanLive &&
        ((mCurrentRunState == RunState.Stopped && checkBox_LiveDisplay.Checked == false) ||
         (mCurrentRunState == RunState.RunningLive && checkBox_LiveDisplay.Checked == true));

      btnRunCont.Enabled = !mInitError && (!running || runningContinuous);
      btnRunCont.Text = runningContinuous ? (ResourceUtility.GetString("RtStopButton")) :
        (ResourceUtility.GetString("RtRunContinuouslyButton"));

      button_ResetStatistics.Enabled = !mInitError && !runningLive;
      button_ResetStatisticsForAllJobs.Enabled = !mInitError && !runningLive;

      Wizard_EnableControls(running);

      // update the monitor window for live display
      int count = mJM == null ? 0 : mJM.JobCount;
      for (int j = 0; j < count; ++j)
      {
        if (j < cogJobResultHistoryCollectionEdit1.SelectorControls.Count)
        {
          Control ctl = (Control)cogJobResultHistoryCollectionEdit1.SelectorControls[mHistoryCollection[j]];
          if (runningLive)
          {
            bool waitingForStop = !checkBox_LiveDisplay.Enabled;
            ctl.Enabled = !waitingForStop && (mJM.Job(j).AcqFifo != null) &&
              (j == mSelectedJob || mJM.Job(j).State == CogJobStateConstants.Stopped);
          }
          else
            ctl.Enabled = true;
        }
      }
    }

    private void UpdateOnlineStatus()
    {
      // update the online/offline status indication

      // check if update needed
      if (label_Online.Tag != null && (bool)label_Online.Tag == mJM.IOEnable)
        return;

      string resStr = mJM.IOEnable ? "RtSystemOnline" : "RtSystemOffline";
      string displayStr = ResourceUtility.GetString(resStr);
      label_Online.Text = displayStr;
      label_Online.Tag = mJM.IOEnable;
    }

    private void HandleUserResults()
    {
      // take the latest result and push it into a queue

      ICogRecord result = mJM.UserResult();
      if (result != null)
      {
        string jobName = (string)result.SubRecords["JobName"].Content;
        int jobIndex = Utility.GetJobIndexFromName(mJM, jobName);
        // note - ignore unknown job names
        if (jobIndex >= 0)
        {
          // push the result into the appropriate history queue
          mHistoryCollection[jobIndex].AddNewUserResult(result);

          // pass the result on to any listeners
          VisionControlUserResultAvailableEventHandler delegateCopy = VisionControlUserResultAvailable;
          if (delegateCopy != null)
          {
            delegateCopy(this, new VisionControlUserResultAvailableEventArgs(jobIndex, result));
          }

          lock (mMinimumGuiPeriodTimer)
          {
            mHaveUnpaintedResults = true;
          }
        }
      }
    }

    private void mJM_UserResultAvailable(object sender, CogJobManagerActionEventArgs e)
    {
      HandleUserResults();
      UpdateGuiIfNeeded();
    }

    private void mJM_ImageAvailable(object sender, CogJobActionEventArgs e)
    {
      // called when new images are available in live video mode only

      try
      {
        if (this.InvokeRequired)
        {
          // Call this same function on the GUI thread.
          // Invoke currently has a bug, and it is fixed in .NET2.0
          IAsyncResult async = BeginInvoke(new CogJob.CogImageAvailableEventHandler(mJM_ImageAvailable), new object[] { sender, e });
          while (!async.IsCompleted && !async.AsyncWaitHandle.WaitOne(300, false)) ;
          EndInvoke(async);
          return;
        }

        // display the image if it is from the currently selected job (otherwise ignore it)
        CogJob j = (CogJob)sender;
        int idx = Utility.GetJobIndexFromName(mJM, j.Name);
        if (idx == mSelectedJob)
          cogRecordsDisplay1.Display.Image = j.Image();
      }
      catch { }
    }

    private void Job_Running(object sender, CogJobActionEventArgs e)
    {
      // handles:
      //   - gui updates for job run commands issued via IO

      try
      {
        if (this.InvokeRequired)
        {
          // Call this same function on the GUI thread.
          // No need to wait for it here, so ignore the asyncresult return value and return immediately
          BeginInvoke(new CogJob.CogJobRunningEventHandler(Job_Running), new object[] { sender, e });
          return;
        }

        // if we are getting this event because the live button was pressed, then we don't have
        // any work to do
        bool isLive = mCurrentRunState == RunState.RunningLive;
        if (isLive)
          return;

        RunState newrunstate = RunState.Stopped;

        switch (e.Action)
        {
          case CogActionConstants.RunningContinuous:
            newrunstate = RunState.RunningContinuous;
            break;
          case CogActionConstants.RunningSingle:
            newrunstate = RunState.RunningOnce;
            break;
          default:
            break;
        }

        // only perform gui changes if we haven't done them already
        if (mCurrentRunState != newrunstate)
        {
          mCurrentRunState = newrunstate;
          UpdateControlsEnabled();
        }
      }
      catch { }
    }

    private void mJM_Stopped(object sender, CogJobManagerActionEventArgs e)
    {
      // handles:
      //    - exit from continuous mode
      //    - completion of a single run ("run once")
      //    - exit from live mode

      try
      {
        if (this.InvokeRequired)
        {
          // Call this same function on the GUI thread.
          // No need to wait for it here, so ignore the asyncresult return value and return immediately
          BeginInvoke(new CogJobManager.CogJobManagerStoppedEventHandler(mJM_Stopped), new object[] { sender, e });
          return;
        }

        bool stoppingLive = mCurrentRunState == RunState.RunningLive || checkBox_LiveDisplay.Checked;

        mCurrentRunState = RunState.Stopped;

        if (stoppingLive)
        {
          RestoreJobStates();

          // clear any statistics
          ResetStatisticsForAllJobs();

          // go back to displaying last result for selected job
          cogRecordsDisplay1.Subject = null;
          cogRecordsDisplay1.Display.Image = null;
          UpdateGUIForSelectedJob(true);

          // Need to make sure the checkbox back to unchecked, in case the stopped event is occurring due
          // to IO, instead of a button click.
          // Note that this may cause a "checked == false" event to occur.
          checkBox_LiveDisplay.Checked = false;
        }

        UpdateGui(null, null);
        UpdateControlsEnabled();
        SetResultBarCurrent();
      }
      catch { }
    }

    private void mJM_JobStopped(object sender, CogJobActionEventArgs e)
    {
      if (e.Action == CogActionConstants.StoppedContinuous ||
         e.Action == CogActionConstants.RunningContinuous)
      {
        try
        {
          if (this.InvokeRequired)
          {
            // Call this same function on the GUI thread.
            // No need to wait for it here, so ignore the asyncresult return value and return immediately
            BeginInvoke(new CogJob.CogJobStoppedEventHandler(mJM_JobStopped), new object[] { sender, e });
            return;
          }

          UpdateControlsEnabled();
        }
        catch { }
      }
    }

    private void mJM_ChangedHandler(object sender, CogChangedEventArgs e)
    {
      if ((e.StateFlags & CogJobManager.SfIOEnable) != 0)
      {
        lock (mMinimumGuiPeriodTimer)
        {
          mMinimumGuiUpdateNeeded = true;
        }
      }
    }

    private int FindResultHistoryIndex(object sender)
    {
      int jobIndex;
      for (jobIndex = 0; jobIndex < mHistoryCollection.Count; ++jobIndex)
        if (Object.ReferenceEquals(sender, mHistoryCollection[jobIndex]))
          break;
      if (jobIndex == mHistoryCollection.Count)
        return -1;  // unknown job
      return jobIndex;
    }

    private CogJobResultHistoryEdit FindResultHistoryEdit(CogJob job)
    {
      int jobIndex = Utility.GetJobIndexFromName(mJM, job.Name);
      Cognex.VisionPro.Implementation.Internal.CogToggleButton item =
          (Cognex.VisionPro.Implementation.Internal.CogToggleButton)
          cogJobResultHistoryCollectionEdit1.SelectorControls[mHistoryCollection[jobIndex]];
      return item.Content as CogJobResultHistoryEdit;
    }

    private void Job_ImageQueueOverflowed(object sender, CogJobActionEventArgs e)
    {
      // sets gui "error occurred" icon for given job to "on"
      try
      {
        CogJobResultHistoryEdit edit = FindResultHistoryEdit((CogJob)sender);
        if (!edit.ErrorIconVisible)
        {
          edit.ErrorIconVisible = true;
          edit.ErrorIconClicked += new EventHandler(cogJobResultHistory_ErrorIconClicked);
        }
      }
      catch { }
    }

    private void cogJobResultHistory_ErrorIconClicked(object sender, System.EventArgs e)
    {
      ICogJobResultHistory history = ((CogJobResultHistoryEdit)sender).Subject;

      // get job name
      int jobIndex = FindResultHistoryIndex(history);
      if (jobIndex < 0)
        return;

      string jobname = mJM.Job(jobIndex).Name;

      // for now, show a brief error message.  in the future, we may bring up a more
      // flexible error log here
      MessageBox.Show(ResourceUtility.FormatString("RtImageQueueOverrun", jobname),
        mApplicationName, MessageBoxButtons.OK);

      // since the message has been viewed, now clear the sender's error icon display
      CogJobResultHistoryEdit edit = FindResultHistoryEdit(mJM.Job(jobIndex));
      edit.ErrorIconVisible = false;
      edit.ErrorIconClicked -= new EventHandler(cogJobResultHistory_ErrorIconClicked);
    }

    private void UpdateGUIForSelectedJobChange(int oldJob)
    {
      // update the gui when the user changes the currently selected job

      TabPage oldSelected = this.tabControl_JobTabs.SelectedTab;
      ArrayList newPagesList = new ArrayList();

      // add in the tabs for the selected job
      // set the selected job text
      Wizard_AddJobTabs(newPagesList);

      // remove all the tabs
      tabControl_JobTabs.Controls.Clear();

      // add in the tabs available at current access level
      foreach (TabPage page in newPagesList)
      {
        if (page.Tag == null || Utility.AccessAllowed(page.Tag.ToString(), mCurrentAccessLevel))
          tabControl_JobTabs.Controls.Add(page);
      }
      tabControl_JobTabs.Controls.Add(tabPage_JobN_JobStatistics);

      if (tabControl_JobTabs.TabPages.Contains(oldSelected))
        this.tabControl_JobTabs.SelectedTab = oldSelected;
      else if (tabControl_JobTabs.TabPages.Count > 0)
        this.tabControl_JobTabs.SelectedTab = tabControl_JobTabs.TabPages[0];

      // handle job change while live video enabled
      if (this.mCurrentRunState == RunState.RunningLive && oldJob >= 0)
      {
        // start new job
        this.StartLiveDisplay(mSelectedJob);
        // stop old job
        this.StopLiveDisplay(oldJob);
      }

      UpdateControlsEnabled();
      UpdateStatisticsForJob(mSelectedJob);
    }

    private static string[] _updateDisplayStrings = new string[] { "ShowLastRunRecordForUserQueue", "LastRun" };

    private void UpdateGUIForSelectedJob(bool newSelectedJob)
    {
      // update the image and result bar to reflect the currently selected item of the
      // the currently selected job

      ICogRecord result = mHistoryCollection[mSelectedJob].CurrentItem;
      if (result == null)
        return;

      if (mCurrentRunState != RunState.RunningLive)
      {
        if (mCurrentOptionsFile.EnableImageDisplay)
        {
          // take the LastRunRecord (for the currently selected job) and put it in the record display.
          // put an empty record in if no LastRunRecord is available
          if (!Utility.AddRecordToDisplay(cogRecordsDisplay1, result, _updateDisplayStrings, newSelectedJob))
            cogRecordsDisplay1.Subject = null;
        }
        else
          cogRecordsDisplay1.Subject = null;
      }

      SetResultBarCurrent();
    }

    private void UpdateGUIForJob(int idx)
    {
      // update the tab pages to reflect the currently selected item of the the currently
      // selected job

      ICogRecord result = mHistoryCollection[idx].CurrentItem;

      // fill in the tab results
      Wizard_UpdateJobResults(idx, result);
    }

    private void SetResultBarCurrent()
    {
      string text;
      CogRunStatus rs = null;

      text = mJM.Job(mSelectedJob).Name;

      if (mCurrentRunState == RunState.RunningLive)
        text += ": " + ResourceUtility.GetString("RtLiveImageButton");
      else
      {
        ICogRecord result = mHistoryCollection[mSelectedJob].CurrentItem;

        if (result != null)
        {
          rs = (CogRunStatus)result.SubRecords["RunStatus"].Content;

          text += ": " + (string)this.mResultTextHash[rs.Result];
        }
      }

      label_ResultBar.Text = text;
      label_ResultBar.BackColor = GetColorFromRunStatus(rs);
    }

    private System.Drawing.Color GetColorFromRunStatus(CogRunStatus status)
    {
      System.Drawing.Color color;
      if (status != null)
      {
        switch (status.Result)
        {
          case CogToolResultConstants.Accept:
            color = System.Drawing.Color.FromArgb(0, 200, 0);
            break;
          case CogToolResultConstants.Warning:
            color = System.Drawing.Color.Yellow;
            break;
          case CogToolResultConstants.Reject:
          case CogToolResultConstants.Error:
          default:
            color = System.Drawing.Color.Red;
            break;
        }
      }
      else
        color = System.Drawing.Color.FromKnownColor(KnownColor.ControlDark);

      return color;
    }

    private void cogJobResultHistoryCollectionEdit1_SelectedJobIndexChanged(object sender, System.EventArgs e)
    {
      if (cogJobResultHistoryCollectionEdit1.Subject != null && cogJobResultHistoryCollectionEdit1.SelectedIndex >= 0 &&
        cogJobResultHistoryCollectionEdit1.SelectedIndex != mSelectedJob)
      {
        int oldJob = mSelectedJob;
        mSelectedJob = cogJobResultHistoryCollectionEdit1.SelectedIndex;

        UpdateGUIForSelectedJobChange(oldJob);
        UpdateGUIForSelectedJob(true);
      }
    }

    private void cogJobResultHistory_CurrentItemChanged(object sender, System.EventArgs e)
    {
      bool newResultForSelectedJob = false;

      int jobIndex = FindResultHistoryIndex(sender);
      if (jobIndex < 0)
        return;

      if (jobIndex == mSelectedJob)
        newResultForSelectedJob = true;

      UpdateGUIForJob(jobIndex);

      // if there is a new result for the selected job, update the gui now
      if (newResultForSelectedJob)
        UpdateGUIForSelectedJob(false);
    }
    #endregion

    #region Live Display
    private void StartLiveDisplay(int jobNumber)
    {
      CogJob j = mJM.Job(jobNumber);
      if (j.State == CogJobStateConstants.Stopped)
        j.RunContinuous();
    }

    private void StopLiveDisplay(int jobNumber)
    {
      CogJob j = mJM.Job(jobNumber);
      if (j.State == CogJobStateConstants.RunningContinuous)
        j.Stop();
    }

    private void checkBox_LiveDisplay_CheckedChanged(object sender, System.EventArgs e)
    {
      if (checkBox_LiveDisplay.Checked == true)
      {
        // clear stats
        ResetStatisticsForAllJobs();
        for (int i = 0; i < mJM.JobCount; i++)
          UpdateStatisticsForJob(i);

        // enable live
        mCurrentRunState = RunState.RunningLive;
        SetResultBarCurrent();
        cogRecordsDisplay1.Subject = null;

        // save old modes & setup jobs for live
        SetupForLive();

        try
        {
          StartLiveDisplay(mSelectedJob);
        }
        catch (Cognex.VisionPro.Exceptions.CogException ex)
        {
          RestoreJobStates();
          mCurrentRunState = RunState.Stopped;
          SetResultBarCurrent();
          MessageBox.Show(ResourceUtility.GetString("RtUnexpectedErrorQB") + ex.Message,
            mApplicationName);

          // need to set the checkbox back to unchecked - note that this causes a recurse call
          // to occur, so the "checked == false" handling below needs to be able to handle this
          checkBox_LiveDisplay.Checked = false;
        }
      }
      else
      {
        // stop live
        StopLiveDisplay(mSelectedJob);
      }

      UpdateControlsEnabled();
    }

    private void SetupForLive()
    {
      mJobData = new JobData[mJM.JobCount];
      for (int i = 0; i < mJobData.Length; ++i)
      {
        mJobData[i] = new JobData();

        CogJob j = mJM.Job(i);
        mJobData[i].lastRunMode = j.RunMode;
        mJobData[i].lastStartMode = j.StartMode;

        j.StartMode = CogJobStartModeConstants.IssuedAfterAcquisitionCompletes;
        j.RunMode = CogJobRunModeConstants.AcquisitionOnly;
        j.ImageAvailable += new CogJob.CogImageAvailableEventHandler(mJM_ImageAvailable);
        j.Stopped += new CogJob.CogJobStoppedEventHandler(mJM_JobStopped);
      }
    }

    private void RestoreJobStates()
    {
      // restore all jobs start & run modes
      for (int idx = 0; idx < mJM.JobCount; ++idx)
      {
        CogJob j = mJM.Job(idx);
        j.StartMode = mJobData[idx].lastStartMode;
        j.RunMode = mJobData[idx].lastRunMode;
        j.ImageAvailable -= new CogJob.CogImageAvailableEventHandler(mJM_ImageAvailable);
        j.Stopped -= new CogJob.CogJobStoppedEventHandler(mJM_JobStopped);
      }

      // done with jobdata
      mJobData = null;
    }
    #endregion

    #region Login
    private void comboBox_Login_SelectionChangeCommitted(object sender, System.EventArgs e)
    {
      AccessLevel newAccessLevel = ((AccessLevel_Localized)(comboBox_Login.SelectedItem)).val;

      // prompt for a password - only update accessLevel if promt is successful
      if (PromptForAccessLevelChange(newAccessLevel))
        mCurrentAccessLevel = newAccessLevel;

      // update gui to reflect current accessLevel
      foreach (AccessLevel_Localized al in comboBox_Login.Items)
        if (al.val == mCurrentAccessLevel)
          comboBox_Login.SelectedItem = al;
      this.UpdateGUIForSelectedJobChange(-1);
    }

    private bool PromptForAccessLevelChange(AccessLevel newAccessLevel)
    {
      // not using passwords, or going "down" in access level - always allowed
      if (!mUsePasswords || newAccessLevel <= mCurrentAccessLevel)
        return true;

      string expected = mCurrentPasswordFile.GetPasswordForAccessLevel(newAccessLevel);
      if (expected != "")
      {
        // get password from user
        FormPasswordPrompt prompt = new FormPasswordPrompt();
        prompt.Text = ResourceUtility.FormatString("RtEnterPassword", newAccessLevel.ToString());
        DialogResult result = prompt.ShowDialog(this);
        if (result != DialogResult.OK)
          return false;
        if (prompt.Password != expected)
        {
          MessageBox.Show(ResourceUtility.GetString("RtInvalidPassword2"), ResourceUtility.GetString("RtInvalidPassword"));
          return false;
        }
      }

      return true;
    }
    #endregion

    #region Other buttons (config, save settings, about)
    private void button_Configuration_Click(object sender, System.EventArgs e)
    {
      FormConfig frmConfigSelect = new FormConfig(mQuickBuildAccess, mUsePasswords);
      frmConfigSelect.ShowDialog(this);

      switch (frmConfigSelect.Result)
      {
        case FormConfigResult.None:
          break;

        case FormConfigResult.QuickBuild:
          // detach from job manager before displaying edit control
          AttachToJobManager(false);

          // put up a new dialog containing QB editor
          FormQB frm = new FormQB(mJM);
          frm.ShowDialog(this);
          frm.Dispose();

          // prompt for save of vpp file
          string vpp = mLoadedVppFilename;
          string quotedvpp = "\"" + vpp + "\"";
          string saveButtonName = ResourceUtility.GetString("RtSaveSettingsButton");
          string quotedSaveButtonName = "\"" + saveButtonName + "\"";
          string promptStr = ResourceUtility.FormatString("RtSaveSettingsTextAfterConfig", quotedvpp, quotedSaveButtonName);
          PromptToSaveSettings(promptStr);

          // re-attach
          AttachToJobManager(true);
          break;

        case FormConfigResult.SetPasswords:
          FormSetPasswords frmPasswords = new FormSetPasswords(mCurrentPasswordFile);
          frmPasswords.ShowDialog(this);
          break;

        case FormConfigResult.AppOptions:
          FormAppOptions frmOptions = new FormAppOptions(this);
          frmOptions.EnableDisplay = mCurrentOptionsFile.EnableImageDisplay;
          frmOptions.EnableIOAtStartup = mCurrentOptionsFile.EnableIOAtStartup;
          frmOptions.EnableIO = mJM.IOEnable;
          DialogResult result = frmOptions.ShowDialog(this);
          if (result == DialogResult.OK)
          {
            mCurrentOptionsFile.EnableImageDisplay = frmOptions.EnableDisplay;
            mCurrentOptionsFile.EnableIOAtStartup = frmOptions.EnableIOAtStartup;
            mCurrentOptionsFile.Write();

            // handle IO state change
            if (frmOptions.EnableIO != mJM.IOEnable)
            {
              try
              {
                mJM.IOEnable = frmOptions.EnableIO;
              }
              catch (Cognex.VisionPro.Exceptions.CogException ex)
              {
                MessageBox.Show(ResourceUtility.GetString("RtUnexpectedErrorQB") + ex.Message,
                                mApplicationName);
              }
            }
          }
          break;
      }
    }

    private void PromptToSaveSettings(string promptString)
    {
      DialogResult result = MessageBox.Show(this, promptString, ResourceUtility.GetString("RtSaveSettingsTitle"),
        MessageBoxButtons.YesNo);
      if (result == DialogResult.Yes)
      {
        if (mJM.JobsRunningState != CogJobsRunningStateConstants.None)
        {
          MessageBox.Show(ResourceUtility.GetString("RtErrorSavingVpp_Running"), mApplicationName);
          return;
        }

        string vpp = mLoadedVppFilename;
        try
        {
          bool wasAttached = mAttached;
          if (wasAttached)
            AttachToJobManager(false);

          // save the QuickBuild project file
          try
          {
            Utility.FlushAllQueues(mJM);
            CogSerializer.SaveObjectToFile(mJM, vpp);
          }
          catch (Exception ex)
          {
            MessageBox.Show(ResourceUtility.FormatString("RtErrorSavingVpp", vpp) + ex.Message,
              mApplicationName);
          }

          if (wasAttached)
            AttachToJobManager(true);
        }
        catch (Exception ex)
        {
          MessageBox.Show(ResourceUtility.FormatString("RtErrorSavingVpp", vpp) + ex.Message,
            mApplicationName);
        }
      }
    }

    private void button_SaveSettings_Click(object sender, System.EventArgs e)
    {
      string vpp = mLoadedVppFilename;
      string quotedvpp = "\"" + vpp + "\"";
      string promptStr = ResourceUtility.FormatString("RtSaveSettingsText", quotedvpp);

      PromptToSaveSettings(promptStr);
    }

    private void button_About_Click(object sender, System.EventArgs e)
    {
      // resolve the aboutbox text filename
      string aboutFilename = Utility.ResolveAssociatedFilename(mVppFilename, "about.txt");

      FormAbout about = new FormAbout(aboutFilename, this);
      about.Text = ResourceUtility.FormatString("RtAboutTitle", this.Text);
      about.ShowDialog(this);
    }
    #endregion

    #region GUI update support
    /*
     * The GUI update goals of this application are as follows:
     * 
     * 1.  We would like most, if not all, GUI updates to occur in the context of a
     *     QuickBuild job thread.  This helps to avoid the case where GUI updates
     *     occur in a separate thread, causing job threads to block momentarily at
     *     arbitrary times (for some time critical applications, this behavior is
     *     not acceptable).
     * 
     * 2.  We would like to avoid repainting the GUI every time a new job result is
     *     available, as this rate is application dependent and can occur hundreds of
     *     times per second.  Repainting at a very high rate wastes CPU cycles.
     * 
     * The GUI update strategy of this application is as follows:
     * 
     * 1.  Two flags track the status of GUI updates:
     *     mHaveUnpaintedResults - tracks when new results are available that have
     *       not yet been painted.  This flag is set every time a new user result
     *       is generated by the application.
     *     mMinimumGuiUpdateNeeded - indicates that painting is now required - we've
     *       passed the minimum amount of time between paints and new results are
     *       available.
     * 
     * 2.  A timer (mMinimumGuiPeriodTimer) is set to go off every 50 ms.  If the
     *     handler for this timer determines the we have unpainted results, then it
     *     sets the mMinimumGuiUpdateNeeded flag.
     * 
     * 3.  Every time a new user result is generated, the mMinimumGuiUpdateNeeded
     *     flag is checked (in the "UserResultAvailable" event handler).  If an update
     *     is needed, it is performed immediately, which causes it to occur in the context
     *     of a job thread.
     * 
     * 4.  A second timer (mMaximumGuiPeriodTimer) is set to go off every 500 ms.  This
     *     timer handles the case where user results are generated relatively slowly, or
     *     they stop being generated for some reason (triggers stop occurring, etc).  The
     *     event handler for this timer performs a paint.  In this case, the paint is not
     *     performed in a job thread.
     * 
     * 5.  The mMaximumGuiPeriodTimer is reset every time a paint occurs, such that its
     *     handler is only called if a paint has not happened in the last 500 ms.
     */

    private void mMaximumGuiPeriodTimer_Elapsed(object obj)
    {
      UpdateGui(null, null);
    }

    private void UpdateGui(object sender, System.EventArgs e)
    {
      try
      {
        if (mIsClosing)
        {
            return;
        }
        if (this.InvokeRequired)
        {
          // Call this same function on the GUI thread.
          // Invoke currently has a bug, and it is fixed in .NET2.0
          IAsyncResult async = BeginInvoke(new System.EventHandler(UpdateGui), new object[] { sender, e });
          while (!mIsClosing && !async.IsCompleted && !async.AsyncWaitHandle.WaitOne(300, false)) ;

          // if the VisionControl is closing, updating the GUI is not necessary any more, besides it
          // might also cause deadlock
          if (mIsClosing)
          {
              async.AsyncWaitHandle.Close();
          }
          else
          {
              EndInvoke(async);
          }

          return;
        }

        // update everything we can on the gui from here

        lock (mMinimumGuiPeriodTimer)
        {
          mHaveUnpaintedResults = false;
        }

        for (int i = 0; i < mHistoryCollection.Count; ++i)
        {
          CogJobResultHistoryGated hist = (CogJobResultHistoryGated)mHistoryCollection[i];
          hist.SnapshotNow();
        }

        UpdateStatisticsForJob(mSelectedJob);
        UpdateOnlineStatus();

        this.Update();

        ResetMaximumGuiUpdateTimer();
        ResetMinimumGuiUpdateTimer();
        lock (mMinimumGuiPeriodTimer)
        {
          mMinimumGuiUpdateNeeded = false;
        }
      }
      catch { }
    }

    private void ResetMaximumGuiUpdateTimer()
    {
      mMaximumGuiPeriodTimer.Change(MaximumPeriodMs, MaximumPeriodMs);
    }
    private void ResetMinimumGuiUpdateTimer()
    {
      mMinimumGuiPeriodTimer.Change(MinimumPeriodMs, MinimumPeriodMs);
    }

    private void UpdateGuiIfNeeded()
    {
      // this function is called every time a new user result is available.  it performs
      // a paint if the minimum amount of time between paints has elapsed.
      bool updateNeeded;
      lock (mMinimumGuiPeriodTimer)
      {
        updateNeeded = mMinimumGuiUpdateNeeded;
      }

      if (updateNeeded)
        UpdateGui(null, null);
    }

    private void mMinimumGuiPeriodTimer_Elapsed(object obj)
    {
      // the minimum amount of time between paints has elapsed.  if we have any unpainted
      // results, then indicate that the next generated user result should perform a paint.
      bool updateNow = false;

      lock (mMinimumGuiPeriodTimer)
      {
        if (!mMinimumGuiUpdateNeeded && !mHaveUnpaintedResults)
          ResetMaximumGuiUpdateTimer();
        else
        {
          updateNow = true;
          mMinimumGuiUpdateNeeded = true;
        }
      }

      if (updateNow && mCurrentRunState == RunState.Stopped)
        UpdateGui(null, null);
    }

    private void cogJobResultHistory_RequestImmediateUpdate(object sender, System.EventArgs e)
    {
      // called when the user interacts with the scrolling history display (selects a different
      // queue or result record for viewing)
      lock (mMinimumGuiPeriodTimer)
      {
        mMinimumGuiUpdateNeeded = true;
      }
    }
    #endregion

    #region Statistics
    private void ResetStatisticsForAllJobs()
    {
      for (int i = 0; i < mJM.JobCount; i++)
        ResetStatisticsForJob(i);
    }

    private void ResetStatisticsForJob(int i)
    {
      mJM.Job(i).ResetAllStatistics();
      mJM.Job(i).RestartThroughputCalculation();
    }

    private void button_ResetStatisticsForAllJobs_Click(object sender, System.EventArgs e)
    {
      ResetStatisticsForAllJobs();
      lock (mMinimumGuiPeriodTimer)
      {
        mMinimumGuiUpdateNeeded = true;
      }
    }

    private void button_ResetStatistics_Click(object sender, System.EventArgs e)
    {
      ResetStatisticsForJob(mSelectedJob);
      lock (mMinimumGuiPeriodTimer)
      {
        mMinimumGuiUpdateNeeded = true;
      }
    }

    private void UpdateStatisticsForJob(int i)
    {
      // don't update statistics when showing live video
      bool runningLive = mCurrentRunState == RunState.RunningLive;
      if (runningLive)
        return;

      CogJob j = mJM.Job(i);
      textBox_JobN_TotalIterations.Text = j.TotalJobIterations.ToString();
      textBox_JobN_TotalAccept.Text = j.TotalVisionToolAccepts.ToString();
      string percentStr = "";
      if (j.TotalJobIterations > 0)
      {
        double p = j.TotalVisionToolAccepts * 100.0 / j.TotalJobIterations;
        percentStr = p.ToString("0.0");
      }

      textBox_JobN_TotalAccept_Percent.Text = percentStr;
      textBox_JobN_TotalReject.Text = j.TotalVisionToolRejects.ToString();
      textBox_JobN_TotalWarning.Text = j.TotalVisionToolWarnings.ToString();
      textBox_JobN_TotalError.Text = j.TotalVisionToolErrors.ToString();

      textBox_JobN_TotalAcquisitions.Text = j.TotalAcquisitions.ToString();
      textBox_JobN_TotalAcquisitionErrors.Text = j.TotalAcquisitionErrors.ToString();
      textBox_JobN_TotalAcquisitionOverruns.Text = j.TotalAcquisitionOverruns.ToString();

      if (j.TotalJobThroughputMax != 0)
      {
        textBox_JobN_Throughput.Text = j.TotalJobThroughput.ToString("0.000");
        textBox_JobN_MinThroughput.Text = j.TotalJobThroughputMin.ToString("0.000");
        textBox_JobN_MaxThroughput.Text = j.TotalJobThroughputMax.ToString("0.000");
      }
      else
      {
        string waiting = ResourceUtility.GetString("RtStatsWaiting");
        textBox_JobN_Throughput.Text = waiting;
        textBox_JobN_MinThroughput.Text = waiting;
        textBox_JobN_MaxThroughput.Text = waiting;
      }
    }
    #endregion
  }


  #region Internal helper classes
  internal class JobData
  {
    public CogJobStartModeConstants lastStartMode = CogJobStartModeConstants.IssuedAfterAcquisitionCompletes;
    public CogJobRunModeConstants lastRunMode = CogJobRunModeConstants.AcquisitionAndImageProcessing;
  }

  // helper class to store localized name and enum value, for use in combo box display
  internal class AccessLevel_Localized
  {
    public AccessLevel_Localized(AccessLevel v, string t)
    {
      val = v;
      text = t;
    }

    public override string ToString()
    {
      // return the localized name
      return text;
    }

    public AccessLevel val;
    public string text;
  }
  #endregion

  #region UserResultAvailable event support
  public class VisionControlUserResultAvailableEventArgs
  {
    public int JobIndex;
    public ICogRecord Result;

    public VisionControlUserResultAvailableEventArgs(int jobIndex, ICogRecord result)
    {
      JobIndex = jobIndex;
      Result = result;
    }
  }

  public delegate void VisionControlUserResultAvailableEventHandler(object sender, VisionControlUserResultAvailableEventArgs e);
  #endregion
}
